# -*- coding: utf-8 -*-
"""Agent-Based Neutron Diffusion v7_numbagpu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12qiGQ9F2jNcamV-A9bJuj_f82W-oYJTE
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import time
from numba import jit, cuda
from numba.cuda.random import create_xoroshiro128p_states, xoroshiro128p_uniform_float64
import math

start = time.time()

history = 5000 #specify the number of particles at the beginning
dummy_history = 35000
radius = 5
r_host = np.float64(np.full((dummy_history, 2), -11000))
r = cuda.to_device(r_host)

@cuda.jit
def initialize_particles(rng_states, r, history):
    thread_id = cuda.grid(1)
    if thread_id < history:
        teta = xoroshiro128p_uniform_float64(rng_states, thread_id)*2*np.pi
        position = xoroshiro128p_uniform_float64(rng_states, thread_id)*radius
        r[thread_id, 0] = position * math.sin(teta)
        r[thread_id, 1] = position * math.cos(teta)

threads_per_block = 300
blocks = (dummy_history+threads_per_block-1) // threads_per_block
rng_states = create_xoroshiro128p_states(threads_per_block * blocks, seed=1)

# Launch the kernel
initialize_particles[blocks, threads_per_block](rng_states, r, history)

r_host = r.copy_to_host()

r_host

fps = 20
dt = 1/fps
final_time = 200
steps = int(final_time/dt)

record_host = np.float64(np.full((steps, dummy_history, 2), -11000))
record_host[0,:,:] = r_host[:,:]
record = cuda.to_device(record_host)

fr = np.float64(1)
fuel_host = np.full((1, 2), np.nan)

def initialize_fuel(fuel_host):
    fuel_host[0, 0] = 0
    fuel_host[0, 1] = 0

initialize_fuel(fuel_host)
fuel = cuda.to_device(fuel_host)

speed = 1
v_host = np.float64(np.full((dummy_history, 2), 0))
v = cuda.to_device(v_host)

@cuda.jit
def initialize_speed(rng_states, v, history):
    thread_id = cuda.grid(1)
    if thread_id < history:
        teta = xoroshiro128p_uniform_float64(rng_states, thread_id)*2*np.pi
        v[thread_id, 0] = speed * math.cos(teta)
        v[thread_id, 1] = speed * math.sin(teta)

initialize_speed[blocks, threads_per_block](rng_states, v, history)

@cuda.jit
def update_particle1(i, dummy_history, r, v, fuel, fr, collision, record):
    thread_id = cuda.grid(1)
    if thread_id < dummy_history:
        if r[thread_id, 0] == -11000 or r[thread_id, 0] == 11000:
            pass
        elif (fuel[0, 0] - fr <= r[thread_id, 0] <= fuel[0, 0] + fr and
              fuel[0, 1] - fr <= r[thread_id, 1] <= fuel[0, 1] + fr and
              math.sqrt(r[thread_id, 0]**2 + r[thread_id, 1]**2) <= fr):
            r[thread_id,:] = 11000
            v[thread_id,:] = 0
            collision[thread_id] = 1
        elif math.sqrt(r[thread_id, 0]**2 + r[thread_id, 1]**2) < radius:
            for k in range(r.shape[1]):
                r[thread_id, k] = r[thread_id, k] + v[thread_id, k] * np.float64(dt)
        else:
            distance_to_origin = math.sqrt(r[thread_id, 0]**2 + r[thread_id, 1]**2)
            normal_vectorx = r[thread_id, 0] / distance_to_origin
            normal_vectory = r[thread_id, 1] / distance_to_origin
            dot_product = v[thread_id, 0] * normal_vectorx + v[thread_id, 1] * normal_vectory
            v[thread_id, 0] -= 2 * dot_product * normal_vectorx
            v[thread_id, 1] -= 2 * dot_product * normal_vectory
            for k in range(r.shape[1]):
                r[thread_id, k] = r[thread_id, k] + v[thread_id, k] * np.float64(dt)
        for j in range(2):
            record[i,thread_id,j] = r[thread_id,j]

@jit(nopython=True)
def update_particle2(r_host, v_host):
    born_part = 2
    for i in range(dummy_history):
        if born_part == 0:
            break
        if v_host[i,0] == 0.:
            teta = np.random.uniform(0, 2*np.pi)
            position = np.random.uniform(0, radius)
            r_host[i, 0] = position * math.sin(teta)
            r_host[i, 1] = position * math.cos(teta)
            teta = np.random.uniform(0, 2*np.pi)
            v_host[i, 0] = speed * np.cos(teta)
            v_host[i, 1] = speed * np.sin(teta)
            born_part = born_part-1
        else: continue

for i in range(1,steps):
    collision_host = np.full((dummy_history), 0)
    collision = cuda.to_device(collision_host)
    update_particle1[blocks, threads_per_block](i, dummy_history, r, v, fuel, fr, collision, record)
    collision_host = collision.copy_to_host()
    r_host = r.copy_to_host()
    v_host = v.copy_to_host()
    for k in range(dummy_history):
        if collision_host[k] == 1:
            update_particle2(r_host, v_host)
    r = cuda.to_device(r_host)
    v = cuda.to_device(v_host)

record_host = record.copy_to_host()

end = time.time()
print(f'record_host.shape = {record_host.shape}')
print(f'duration = {end-start}')

part = 0
for i in range(dummy_history):
    if record_host[3999,i,0] != 11000 and record_host[3999,i,0] != -11000:
        part +=1
print('Particles =', part)
